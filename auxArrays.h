#define DEBUG_ERR



struct auxArrays
{
	double A[_V+1][3][_P];
	double V0[9];
	double V1[4][9];
	double E[2][6];
	double G[5][9];

	void iniPerm(const double [_V][3][_P]);
	void getA();
	void getEG();
};



inline double det3x3(const double A[3][_P], const int i[_P])
{
	const double m1=A[1][i[0]]*A[2][i[1]]-A[2][i[0]]*A[1][i[1]],
		m2=A[0][i[1]]*A[2][i[0]]-A[0][i[0]]*A[2][i[1]],
		m3=A[0][i[0]]*A[1][i[1]]-A[0][i[1]]*A[1][i[0]];
	
	return A[0][i[2]]*m1+A[1][i[2]]*m2+A[2][i[2]]*m3;
}



// permute initial data (heuristics)
void auxArrays::iniPerm(const double A0[_V][3][_P])
{
	int m=0, ind[4][_P]={{2,3,1,0}, {2,0,3,1}, {0,1,3,2}, {2,1,0,3}};
	double max_vol=fabs(det3x3(A0[0], ind[0]));
	for (int i=1; i<4; ++i)
	{
		const double vol=fabs(det3x3(A0[0], ind[i]));
		if (vol<max_vol)
		{
			m=i;
			max_vol=vol;
		}
	}

	for (int j=0; j<_V; ++j)
		for (int k=0; k<3; ++k)
			for (int i=0; i<_P; ++i)
				A[j][k][i]=A0[j][k][ind[m][i]];
}



void auxArrays::getA()
{
	for (int i=0; i<3; ++i)
	{
		const double fac=1./sqrt(A[2][0][i]*A[2][0][i]+A[2][1][i]*A[2][1][i]+A[2][2][i]*A[2][2][i]);
		for (int k=0; k<3; ++k) A[2][k][i]*=fac;
	}
	const double fac=1./A[2][2][3];
	for (int k=0; k<3; ++k) A[2][k][3]*=fac;

	const double m1=A[2][1][0]*A[2][2][1]-A[2][2][0]*A[2][1][1],
		m2=A[2][0][1]*A[2][2][0]-A[2][0][0]*A[2][2][1],
		m3=A[2][0][0]*A[2][1][1]-A[2][0][1]*A[2][1][0];

	A[3][0][3]=A[2][0][2]*m1+A[2][1][2]*m2+A[2][2][2]*m3; // determinant

	#ifdef DEBUG_ERR
	{
		if (!A[3][0][3]) std::cout << "degenerate matrix in getA()\n";
	}
	#endif

	A[3][0][3]=1./A[3][0][3];
	// inverse of matrix
	A[3][0][0]=(A[2][1][1]*A[2][2][2]-A[2][2][1]*A[2][1][2])*A[3][0][3];
	A[3][0][1]=(A[2][2][0]*A[2][1][2]-A[2][1][0]*A[2][2][2])*A[3][0][3];
	A[3][0][2]=m1*A[3][0][3];
	A[3][1][0]=(A[2][0][2]*A[2][2][1]-A[2][0][1]*A[2][2][2])*A[3][0][3];
	A[3][1][1]=(A[2][0][0]*A[2][2][2]-A[2][0][2]*A[2][2][0])*A[3][0][3];
	A[3][1][2]=m2*A[3][0][3];
	A[3][2][0]=(A[2][0][1]*A[2][1][2]-A[2][0][2]*A[2][1][1])*A[3][0][3];
	A[3][2][1]=(A[2][0][2]*A[2][1][0]-A[2][0][0]*A[2][1][2])*A[3][0][3];
	A[3][2][2]=m3*A[3][0][3];
}



// basis of null space of mxn matrix A using specifically tailored QR factorization
// result is n-m n-vectors Q
void nullQR(double A[9][2*_P], double Q[9][2], const int n, const int m)
{
	const int nm=n-m, m1=m-1;

	// Hauseholder vectors
	for (int j=0; j<m; ++j)
	{
		double t=0;
		for (int i=j+1; i<n; ++i) t+=A[i][j]*A[i][j];
		double mu=sqrt(A[j][j]*A[j][j]+t);
		mu=(A[j][j]<0)? 1./(A[j][j]-mu):1./(A[j][j]+mu);

		for (int i=j+1; i<n; ++i) A[i][j]*=mu;

		double beta=-2./(1.+t*(mu*mu));
		for (int k=j+1; k<m; ++k)
		{
			double w=A[j][k];
			for (int i=j+1; i<n; ++i) w+=A[i][k]*A[i][j];
			w*=beta;
			for (int i=j+1; i<n; ++i) A[i][k]+=A[i][j]*w;
		}
	}

	// multiply m Householder matrices, inverse order is more efficient
	// we only need last n-m columns of the resulting matrix
	for (int i=0; i<nm; ++i)
		for (int k=0; k<m1; ++k) Q[k][i]=0.;
	
	// start from the mth matrix
	double beta=1.;
	for (int i=m; i<n; ++i) beta+=A[i][m1]*A[i][m1];

	beta=-2./beta;
	for (int k=0; k<nm; ++k)
	{
		Q[m1][k]=A[k+m][m1]*beta;
		for (int i=m; i<n; ++i)
			Q[i][k]=(k==i-m)? 1.+A[i][m1]*Q[m1][k]:A[i][m1]*Q[m1][k];
	}
	
	// multiply by the remaining m-1 matrices
	for (int j=m1-1; j>=0; --j)
	{
		double beta=1.;
		for (int i=j+1; i<n; ++i) beta+=A[i][j]*A[i][j];
		beta=-2./beta;
		for (int k=0; k<nm; ++k)
		{
			double w=Q[j][k];
			for (int i=j+1; i<n; ++i) w+=Q[i][k]*A[i][j];
			w*=beta;
			Q[j][k]+=w;
			for (int i=j+1; i<n; ++i) Q[i][k]+=A[i][j]*w;
		}
	}
}



// compute adjoint matrix to A, which is B = det(A) A^{-1}
void adjoint(const double A[], double B[], bool sym)
{
	if (sym)
	{
		B[0]=A[3]*A[5]-A[4]*A[4];
		B[1]=-A[1]*A[5]+A[2]*A[4];
		B[2]=A[1]*A[4]-A[2]*A[3];
		B[3]=A[0]*A[5]-A[2]*A[2];
		B[4]=-A[0]*A[4]+A[1]*A[2];
		B[5]=A[0]*A[3]-A[1]*A[1];
	}
	else
	{
		B[0]=A[4]*A[8]-A[5]*A[7];
		B[1]=-A[1]*A[8]+A[2]*A[7];
		B[2]=A[1]*A[5]-A[2]*A[4];
		B[3]=-A[3]*A[8]+A[5]*A[6];
		B[4]=A[0]*A[8]-A[2]*A[6];
		B[5]=-A[0]*A[5]+A[2]*A[3];
		B[6]=A[3]*A[7]-A[4]*A[6];
		B[7]=-A[0]*A[7]+A[1]*A[6];
		B[8]=A[0]*A[4]-A[1]*A[3];
	}
}



// C=A*B, sym=1 for symmetric A
void mult(const double A[], double B[], double C[], bool sym)
{
	if (sym)
	{
		C[0]=A[0]*B[0]+A[1]*B[3]+A[2]*B[6];
		C[1]=A[0]*B[1]+A[1]*B[4]+A[2]*B[7];
		C[2]=A[0]*B[2]+A[1]*B[5]+A[2]*B[8];
		C[3]=A[1]*B[0]+A[3]*B[3]+A[4]*B[6];
		C[4]=A[1]*B[1]+A[3]*B[4]+A[4]*B[7];
		C[5]=A[1]*B[2]+A[3]*B[5]+A[4]*B[8];
		C[6]=A[2]*B[0]+A[4]*B[3]+A[5]*B[6];
		C[7]=A[2]*B[1]+A[4]*B[4]+A[5]*B[7];
		C[8]=A[2]*B[2]+A[4]*B[5]+A[5]*B[8];
	}
	else
	{
		C[0]=A[0]*B[0]+A[1]*B[3]+A[2]*B[6];
		C[1]=A[0]*B[1]+A[1]*B[4]+A[2]*B[7];
		C[2]=A[0]*B[2]+A[1]*B[5]+A[2]*B[8];
		C[3]=A[3]*B[0]+A[4]*B[3]+A[5]*B[6];
		C[4]=A[3]*B[1]+A[4]*B[4]+A[5]*B[7];
		C[5]=A[3]*B[2]+A[4]*B[5]+A[5]*B[8];
		C[6]=A[6]*B[0]+A[7]*B[3]+A[8]*B[6];
		C[7]=A[6]*B[1]+A[7]*B[4]+A[8]*B[7];
		C[8]=A[6]*B[2]+A[7]*B[5]+A[8]*B[8];
	}
}



// transpose of matrix A
void trans(double A[])
{
	const double t1=A[1], t2=A[2], t5=A[5];
	A[1]=A[3];
	A[3]=t1;
	A[2]=A[6];
	A[6]=t2;
	A[5]=A[7];
	A[7]=t5;
}



// compute conics E and G
void auxArrays::getEG()
{
	double B[9][2*_P], C[2][9][2*_P], Q[9][2], H[2][9], adjH1[9];
	const double A1[3][_P]={{A[0][0][0], A[0][0][1], A[0][0][2], A[0][0][3]},
		{A[0][1][0], A[0][1][1], A[0][1][2], A[0][1][3]}, 
		{A[0][2][0], A[0][2][1], A[0][2][2], A[0][2][3]}};
	
	for (int i=0; i<_P; ++i)
	{
		const int i2=i*2, i3=i2+1;
		for (int j=0; j<2; ++j)
		{
			C[j][0][i2]=C[j][1][i2]=C[j][2][i2]=0.;
			C[j][3][i2]=-A1[2][i]*A[j][0][i];
			C[j][4][i2]=-A1[2][i]*A[j][1][i];
			C[j][5][i2]=-A1[2][i]*A[j][2][i];
			C[j][6][i2]=A1[1][i]*A[j][0][i];
			C[j][7][i2]=A1[1][i]*A[j][1][i];
			C[j][8][i2]=A1[1][i]*A[j][2][i];
			
			C[j][3][i3]=C[j][4][i3]=C[j][5][i3]=0.;
			C[j][0][i3]=-C[j][3][i2];
			C[j][1][i3]=-C[j][4][i2];
			C[j][2][i3]=-C[j][5][i2];
			C[j][6][i3]=-A1[0][i]*A[j][0][i];
			C[j][7][i3]=-A1[0][i]*A[j][1][i];
			C[j][8][i3]=-A1[0][i]*A[j][2][i];
		}
		B[0][i]=A1[0][i]*A1[0][i];
		B[1][i]=2.*A1[1][i]*A1[0][i];
		B[2][i]=2.*A1[2][i]*A1[0][i];
		B[3][i]=A1[1][i]*A1[1][i];
		B[4][i]=2.*A1[2][i]*A1[1][i];
		B[5][i]=A1[2][i]*A1[2][i];
	}
	
	nullQR(B, Q, 6, 4);
	for (int j=0; j<2; ++j)
		for (int i=0; i<6; ++i) E[j][i]=Q[i][j];
	
	for (int j=0; j<2; ++j)
	{
		nullQR(C[j], Q, 9, 8);
		for (int i=0; i<9; ++i) H[j][i]=Q[i][0];
	}
	adjoint(H[0], V0, 0);
	adjoint(H[1], adjH1, 0);

	// omega = (H.H')*
	double HH[2][6], omega[2][6], D[2][6], adjD[2][6];
	for (int j=0; j<2; ++j)
	{
		HH[j][0]=H[j][0]*H[j][0]+H[j][1]*H[j][1]+H[j][2]*H[j][2];
		HH[j][1]=H[j][0]*H[j][3]+H[j][1]*H[j][4]+H[j][2]*H[j][5];
		HH[j][2]=H[j][0]*H[j][6]+H[j][1]*H[j][7]+H[j][2]*H[j][8];
		HH[j][3]=H[j][3]*H[j][3]+H[j][4]*H[j][4]+H[j][5]*H[j][5];
		HH[j][4]=H[j][3]*H[j][6]+H[j][4]*H[j][7]+H[j][5]*H[j][8];
		HH[j][5]=H[j][6]*H[j][6]+H[j][7]*H[j][7]+H[j][8]*H[j][8];
		adjoint(HH[j], omega[j], 1);
		adjoint(omega[j], D[j], 1);
		adjoint(D[j], adjD[j], 1);
	}

	const double detD1=adjD[1][0]*D[1][0]+adjD[1][1]*D[1][1]+adjD[1][2]*D[1][2];
	double DE[2][2][9], t[2][2], tt[2][3], U[2][2][9], U0[2][9];
	for (int j=0; j<2; ++j)
	{
		for (int k=0; k<2; ++k)
		{
			DE[j][k][0]=D[j][0]*E[k][0]+D[j][1]*E[k][1]+D[j][2]*E[k][2];
			DE[j][k][1]=D[j][0]*E[k][1]+D[j][1]*E[k][3]+D[j][2]*E[k][4];
			DE[j][k][2]=D[j][0]*E[k][2]+D[j][1]*E[k][4]+D[j][2]*E[k][5];
			DE[j][k][3]=D[j][1]*E[k][0]+D[j][3]*E[k][1]+D[j][4]*E[k][2];
			DE[j][k][4]=D[j][1]*E[k][1]+D[j][3]*E[k][3]+D[j][4]*E[k][4];
			DE[j][k][5]=D[j][1]*E[k][2]+D[j][3]*E[k][4]+D[j][4]*E[k][5];
			DE[j][k][6]=D[j][2]*E[k][0]+D[j][4]*E[k][1]+D[j][5]*E[k][2];
			DE[j][k][7]=D[j][2]*E[k][1]+D[j][4]*E[k][3]+D[j][5]*E[k][4];
			DE[j][k][8]=D[j][2]*E[k][2]+D[j][4]*E[k][4]+D[j][5]*E[k][5];

			t[j][k]=DE[j][k][0]+DE[j][k][4]+DE[j][k][8];

			U[j][k][0]=2.*DE[j][k][0]-t[j][k];
			U[j][k][1]=2.*DE[j][k][1];
			U[j][k][2]=2.*DE[j][k][2];
			U[j][k][3]=2.*DE[j][k][3];
			U[j][k][4]=2.*DE[j][k][4]-t[j][k];
			U[j][k][5]=2.*DE[j][k][5];
			U[j][k][6]=2.*DE[j][k][6];
			U[j][k][7]=2.*DE[j][k][7];
			U[j][k][8]=2.*DE[j][k][8]-t[j][k];
		}
		tt[j][0]=t[j][0]*t[j][0];
		tt[j][1]=2.*t[j][0]*t[j][1];
		tt[j][2]=t[j][1]*t[j][1];
	}

	for (int k=0; k<2; ++k)
	{
		U0[k][0]=DE[0][k][0]-t[0][k];
		U0[k][1]=DE[0][k][1];
		U0[k][2]=DE[0][k][2];
		U0[k][3]=DE[0][k][3];
		U0[k][4]=DE[0][k][4]-t[0][k];
		U0[k][5]=DE[0][k][5];
		U0[k][6]=DE[0][k][6];
		U0[k][7]=DE[0][k][7];
		U0[k][8]=DE[0][k][8]-t[0][k];
	}
	
	double adjE[3][6], adjU1[3][9];
	adjoint(E[0], adjE[0], 1);
	adjoint(E[1], adjE[2], 1);
	adjE[1][0]=E[0][3]*E[1][5]-2.*E[0][4]*E[1][4]+E[0][5]*E[1][3];
	adjE[1][1]=-E[0][1]*E[1][5]+E[0][2]*E[1][4]+E[0][4]*E[1][2]-E[0][5]*E[1][1];
	adjE[1][2]=E[0][1]*E[1][4]-E[0][2]*E[1][3]-E[0][3]*E[1][2]+E[0][4]*E[1][1];
	adjE[1][3]=E[0][0]*E[1][5]-2.*E[0][2]*E[1][2]+E[0][5]*E[1][0];
	adjE[1][4]=-E[0][0]*E[1][4]+E[0][1]*E[1][2]+E[0][2]*E[1][1]-E[0][4]*E[1][0];
	adjE[1][5]=E[0][0]*E[1][3]-2.*E[0][1]*E[1][1]+E[0][3]*E[1][0];
	
	adjoint(U[1][0], adjU1[0], 0);
	adjoint(U[1][1], adjU1[2], 0);
	adjU1[1][0]=U[1][0][4]*U[1][1][8]+U[1][1][4]*U[1][0][8]-U[1][0][5]*U[1][1][7]-U[1][1][5]*U[1][0][7];
	adjU1[1][1]=-U[1][0][1]*U[1][1][8]-U[1][1][1]*U[1][0][8]+U[1][0][2]*U[1][1][7]+U[1][1][2]*U[1][0][7];
	adjU1[1][2]=U[1][0][1]*U[1][1][5]+U[1][1][1]*U[1][0][5]-U[1][0][2]*U[1][1][4]-U[1][1][2]*U[1][0][4];
	adjU1[1][3]=-U[1][0][3]*U[1][1][8]-U[1][1][3]*U[1][0][8]+U[1][0][5]*U[1][1][6]+U[1][1][5]*U[1][0][6];
	adjU1[1][4]=U[1][0][0]*U[1][1][8]+U[1][1][0]*U[1][0][8]-U[1][0][2]*U[1][1][6]-U[1][1][2]*U[1][0][6];
	adjU1[1][5]=-U[1][0][0]*U[1][1][5]-U[1][1][0]*U[1][0][5]+U[1][0][2]*U[1][1][3]+U[1][1][2]*U[1][0][3];
	adjU1[1][6]=U[1][0][3]*U[1][1][7]+U[1][1][3]*U[1][0][7]-U[1][0][4]*U[1][1][6]-U[1][1][4]*U[1][0][6];
	adjU1[1][7]=-U[1][0][0]*U[1][1][7]-U[1][1][0]*U[1][0][7]+U[1][0][1]*U[1][1][6]+U[1][1][1]*U[1][0][6];
	adjU1[1][8]=U[1][0][0]*U[1][1][4]+U[1][1][0]*U[1][0][4]-U[1][0][1]*U[1][1][3]-U[1][1][1]*U[1][0][3];
	
	double W4[3][9];
	mult(adjH1, adjU1[0], W4[0], 0);
	mult(adjH1, adjU1[1], W4[1], 0);
	mult(adjH1, adjU1[2], W4[2], 0);
	
	mult(W4[0], U[0][0], V1[0], 0);
	mult(W4[2], U[0][1], V1[3], 0);
	for (int k=1; k<3; ++k)
	{
		const int k1=k-1;
		V1[k][0]=W4[k][0]*U[0][0][0]+W4[k1][0]*U[0][1][0]+W4[k][1]*U[0][0][3]+W4[k1][1]*U[0][1][3]+W4[k][2]*U[0][0][6]+W4[k1][2]*U[0][1][6];
		V1[k][1]=W4[k][0]*U[0][0][1]+W4[k1][0]*U[0][1][1]+W4[k][1]*U[0][0][4]+W4[k1][1]*U[0][1][4]+W4[k][2]*U[0][0][7]+W4[k1][2]*U[0][1][7];
		V1[k][2]=W4[k1][0]*U[0][1][2]+W4[k1][1]*U[0][1][5]+W4[k1][2]*U[0][1][8]+W4[k][0]*U[0][0][2]+W4[k][1]*U[0][0][5]+W4[k][2]*U[0][0][8];
		V1[k][3]=W4[k][3]*U[0][0][0]+W4[k1][3]*U[0][1][0]+W4[k][4]*U[0][0][3]+W4[k1][4]*U[0][1][3]+W4[k][5]*U[0][0][6]+W4[k1][5]*U[0][1][6];
		V1[k][4]=W4[k][3]*U[0][0][1]+W4[k1][3]*U[0][1][1]+W4[k][4]*U[0][0][4]+W4[k1][4]*U[0][1][4]+W4[k][5]*U[0][0][7]+W4[k1][5]*U[0][1][7];
		V1[k][5]=W4[k][3]*U[0][0][2]+W4[k1][3]*U[0][1][2]+W4[k][4]*U[0][0][5]+W4[k1][4]*U[0][1][5]+W4[k][5]*U[0][0][8]+W4[k1][5]*U[0][1][8];
		V1[k][6]=W4[k][6]*U[0][0][0]+W4[k1][6]*U[0][1][0]+W4[k][7]*U[0][0][3]+W4[k1][7]*U[0][1][3]+W4[k][8]*U[0][0][6]+W4[k1][8]*U[0][1][6];
		V1[k][7]=W4[k][6]*U[0][0][1]+W4[k1][6]*U[0][1][1]+W4[k][7]*U[0][0][4]+W4[k1][7]*U[0][1][4]+W4[k][8]*U[0][0][7]+W4[k1][8]*U[0][1][7];
		V1[k][8]=W4[k][6]*U[0][0][2]+W4[k1][6]*U[0][1][2]+W4[k][7]*U[0][0][5]+W4[k1][7]*U[0][1][5]+W4[k][8]*U[0][0][8]+W4[k1][8]*U[0][1][8];
	}
	
	double detE[4], r1[3], s1[5];
	detE[0]=E[0][0]*adjE[0][0]+E[0][1]*adjE[0][1]+E[0][2]*adjE[0][2];
	detE[1]=E[1][0]*adjE[0][0]+E[0][0]*adjE[1][0]+E[1][1]*adjE[0][1]+E[0][1]*adjE[1][1]+E[1][2]*adjE[0][2]+E[0][2]*adjE[1][2];
	detE[2]=E[1][0]*adjE[1][0]+E[0][0]*adjE[2][0]+E[1][1]*adjE[1][1]+E[0][1]*adjE[2][1]+E[1][2]*adjE[1][2]+E[0][2]*adjE[2][2];
	detE[3]=E[1][0]*adjE[2][0]+E[1][1]*adjE[2][1]+E[1][2]*adjE[2][2];
	
	r1[0]=(DE[1][0][4]+DE[1][0][0])*DE[1][0][8]-DE[1][0][5]*DE[1][0][7]-DE[1][0][2]*DE[1][0][6]+DE[1][0][0]*DE[1][0][4]-DE[1][0][1]*DE[1][0][3];
	r1[1]=(DE[1][0][4]+DE[1][0][0])*DE[1][1][8]+(DE[1][1][4]+DE[1][1][0])*DE[1][0][8]-DE[1][0][5]*DE[1][1][7]-DE[1][1][5]*DE[1][0][7]-
		DE[1][0][2]*DE[1][1][6]-DE[1][1][2]*DE[1][0][6]+DE[1][0][0]*DE[1][1][4]+DE[1][1][0]*DE[1][0][4]-DE[1][0][1]*DE[1][1][3]-DE[1][1][1]*DE[1][0][3];
	r1[2]=(DE[1][1][4]+DE[1][1][0])*DE[1][1][8]-DE[1][1][5]*DE[1][1][7]-DE[1][1][2]*DE[1][1][6]+DE[1][1][0]*DE[1][1][4]-DE[1][1][1]*DE[1][1][3];

	const double t0=tt[1][0]-4.*r1[0], t1=tt[1][1]-4.*r1[1], t2=tt[1][2]-4.*r1[2];
	s1[0]=t[1][0]*(16.*detE[0]*detD1+t[1][0]*t0);
	s1[1]=t[1][1]*(16.*detE[0]*detD1+t[1][0]*t0)+t[1][0]*(16.*detE[1]*detD1+t[1][1]*t0+t[1][0]*t1);
	s1[2]=t[1][1]*(16.*detE[1]*detD1+t[1][1]*t0+t[1][0]*t1)+t[1][0]*(16.*detE[2]*detD1+t[1][1]*t1+t[1][0]*t2);
	s1[3]=t[1][1]*(16.*detE[2]*detD1+t[1][1]*t1+t[1][0]*t2)+t[1][0]*(16.*detE[3]*detD1+t[1][1]*t2);
	s1[4]=t[1][1]*(16.*detE[3]*detD1+t[1][1]*t2);
	
	const double t4[5]={tt[0][0]*tt[1][0], tt[0][1]*tt[1][0]+tt[0][0]*tt[1][1],
		tt[0][2]*tt[1][0]+tt[0][1]*tt[1][1]+tt[0][0]*tt[1][2], tt[0][2]*tt[1][1]+tt[0][1]*tt[1][2], tt[0][2]*tt[1][2]};
	
	double W0[2][9], W1[4][9], G0[5][9];
	mult(adjD[1], U[0][0], W0[0], 1);
	mult(adjD[1], U[0][1], W0[1], 1);
	
	mult(adjE[0], W0[0], W1[0], 1);
	mult(adjE[2], W0[1], W1[3], 1);
	for (int k=1; k<3; ++k)
	{
		const int k1=k-1;
		W1[k][0]=adjE[k][0]*W0[0][0]+adjE[k1][0]*W0[1][0]+adjE[k][1]*W0[0][3]+adjE[k1][1]*W0[1][3]+adjE[k][2]*W0[0][6]+adjE[k1][2]*W0[1][6];
		W1[k][1]=adjE[k][0]*W0[0][1]+adjE[k1][0]*W0[1][1]+adjE[k][1]*W0[0][4]+adjE[k1][1]*W0[1][4]+adjE[k][2]*W0[0][7]+adjE[k1][2]*W0[1][7];
		W1[k][2]=adjE[k][0]*W0[0][2]+adjE[k1][0]*W0[1][2]+adjE[k][1]*W0[0][5]+adjE[k1][1]*W0[1][5]+adjE[k][2]*W0[0][8]+adjE[k1][2]*W0[1][8];
		W1[k][3]=adjE[k][1]*W0[0][0]+adjE[k1][1]*W0[1][0]+adjE[k][3]*W0[0][3]+adjE[k1][3]*W0[1][3]+adjE[k][4]*W0[0][6]+adjE[k1][4]*W0[1][6];
		W1[k][4]=adjE[k][1]*W0[0][1]+adjE[k1][1]*W0[1][1]+adjE[k][3]*W0[0][4]+adjE[k1][3]*W0[1][4]+adjE[k][4]*W0[0][7]+adjE[k1][4]*W0[1][7];
		W1[k][5]=adjE[k][1]*W0[0][2]+adjE[k1][1]*W0[1][2]+adjE[k][3]*W0[0][5]+adjE[k1][3]*W0[1][5]+adjE[k][4]*W0[0][8]+adjE[k1][4]*W0[1][8];
		W1[k][6]=adjE[k][2]*W0[0][0]+adjE[k1][2]*W0[1][0]+adjE[k][4]*W0[0][3]+adjE[k1][4]*W0[1][3]+adjE[k][5]*W0[0][6]+adjE[k1][5]*W0[1][6];
		W1[k][7]=adjE[k][2]*W0[0][1]+adjE[k1][2]*W0[1][1]+adjE[k][4]*W0[0][4]+adjE[k1][4]*W0[1][4]+adjE[k][5]*W0[0][7]+adjE[k1][5]*W0[1][7];
		W1[k][8]=adjE[k][2]*W0[0][2]+adjE[k1][2]*W0[1][2]+adjE[k][4]*W0[0][5]+adjE[k1][4]*W0[1][5]+adjE[k][5]*W0[0][8]+adjE[k1][5]*W0[1][8];
	}

	trans(W0[0]);
	trans(W0[1]);
	mult(W0[0], W1[0], G0[0], 0);
	mult(W0[1], W1[3], G0[4], 0);
	for (int k=1; k<4; ++k)
	{
		const int k1=k-1;
		G0[k][0]=W0[1][0]*W1[k1][0]+W0[0][0]*W1[k][0]+W0[1][1]*W1[k1][3]+W0[0][1]*W1[k][3]+W0[1][2]*W1[k1][6]+W0[0][2]*W1[k][6];
		G0[k][1]=W0[1][0]*W1[k1][1]+W0[0][0]*W1[k][1]+W0[1][1]*W1[k1][4]+W0[0][1]*W1[k][4]+W0[1][2]*W1[k1][7]+W0[0][2]*W1[k][7];
		G0[k][2]=W0[1][0]*W1[k1][2]+W0[0][0]*W1[k][2]+W0[1][1]*W1[k1][5]+W0[0][1]*W1[k][5]+W0[1][2]*W1[k1][8]+W0[0][2]*W1[k][8];
		G0[k][4]=W0[1][3]*W1[k1][1]+W0[0][3]*W1[k][1]+W0[1][4]*W1[k1][4]+W0[0][4]*W1[k][4]+W0[1][5]*W1[k1][7]+W0[0][5]*W1[k][7];
		G0[k][5]=W0[1][3]*W1[k1][2]+W0[0][3]*W1[k][2]+W0[1][4]*W1[k1][5]+W0[0][4]*W1[k][5]+W0[1][5]*W1[k1][8]+W0[0][5]*W1[k][8];
		G0[k][8]=W0[1][6]*W1[k1][2]+W0[0][6]*W1[k][2]+W0[1][7]*W1[k1][5]+W0[0][7]*W1[k][5]+W0[1][8]*W1[k1][8]+W0[0][8]*W1[k][8];
	}
	
	double W2[2][9], W3[3][9], G1[5][9];
	mult(adjD[1], U0[0], W2[0], 1);
	mult(adjD[1], U0[1], W2[1], 1);
	
	trans(DE[0][0]);
	trans(DE[0][1]);
	mult(DE[0][0], W2[0], W3[0], 0);
	mult(DE[0][1], W2[1], W3[2], 0);
	W3[1][0]=DE[0][1][0]*W2[0][0]+DE[0][0][0]*W2[1][0]+DE[0][1][1]*W2[0][3]+DE[0][0][1]*W2[1][3]+DE[0][1][2]*W2[0][6]+DE[0][0][2]*W2[1][6];
	W3[1][1]=DE[0][1][0]*W2[0][1]+DE[0][0][0]*W2[1][1]+DE[0][1][1]*W2[0][4]+DE[0][0][1]*W2[1][4]+DE[0][1][2]*W2[0][7]+DE[0][0][2]*W2[1][7];
	W3[1][2]=DE[0][1][0]*W2[0][2]+DE[0][0][0]*W2[1][2]+DE[0][1][1]*W2[0][5]+DE[0][0][1]*W2[1][5]+DE[0][1][2]*W2[0][8]+DE[0][0][2]*W2[1][8];
	W3[1][3]=W2[0][0]*DE[0][1][3]+W2[0][3]*DE[0][1][4]+W2[0][6]*DE[0][1][5]+W2[1][0]*DE[0][0][3]+W2[1][3]*DE[0][0][4]+W2[1][6]*DE[0][0][5];
	W3[1][4]=DE[0][1][3]*W2[0][1]+DE[0][0][3]*W2[1][1]+DE[0][1][4]*W2[0][4]+DE[0][0][4]*W2[1][4]+DE[0][1][5]*W2[0][7]+DE[0][0][5]*W2[1][7];
	W3[1][5]=DE[0][1][3]*W2[0][2]+DE[0][0][3]*W2[1][2]+DE[0][1][4]*W2[0][5]+DE[0][0][4]*W2[1][5]+DE[0][1][5]*W2[0][8]+DE[0][0][5]*W2[1][8];
	W3[1][6]=DE[0][1][6]*W2[0][0]+DE[0][0][6]*W2[1][0]+DE[0][1][7]*W2[0][3]+DE[0][0][7]*W2[1][3]+DE[0][1][8]*W2[0][6]+DE[0][0][8]*W2[1][6];
	W3[1][7]=DE[0][1][6]*W2[0][1]+DE[0][0][6]*W2[1][1]+DE[0][1][7]*W2[0][4]+DE[0][0][7]*W2[1][4]+DE[0][1][8]*W2[0][7]+DE[0][0][8]*W2[1][7];
	W3[1][8]=DE[0][1][6]*W2[0][2]+DE[0][0][6]*W2[1][2]+DE[0][1][7]*W2[0][5]+DE[0][0][7]*W2[1][5]+DE[0][1][8]*W2[0][8]+DE[0][0][8]*W2[1][8];
	
	for (int i=0; i<9; ++i)
	{
		G1[0][i]=tt[1][0]*W3[0][i];
		G1[1][i]=tt[1][1]*W3[0][i]+tt[1][0]*W3[1][i];
		G1[2][i]=tt[1][2]*W3[0][i]+tt[1][1]*W3[1][i]+tt[1][0]*W3[2][i];
		G1[3][i]=tt[1][2]*W3[1][i]+tt[1][1]*W3[2][i];
		G1[4][i]=tt[1][2]*W3[2][i];
	}
	
	for (int k=0; k<5; ++k)
	{
		G[k][0]=4.*(G0[k][0]-G1[k][0])+s1[k]*adjD[0][0]-t4[k]*adjD[1][0];
		G[k][1]=4.*(G0[k][1]-G1[k][1])+s1[k]*adjD[0][1]-t4[k]*adjD[1][1];
		G[k][2]=4.*(G0[k][2]-G1[k][2])+s1[k]*adjD[0][2]-t4[k]*adjD[1][2];
		G[k][3]=4.*(G0[k][1]-G1[k][3])+s1[k]*adjD[0][1]-t4[k]*adjD[1][1];
		G[k][4]=4.*(G0[k][4]-G1[k][4])+s1[k]*adjD[0][3]-t4[k]*adjD[1][3];
		G[k][5]=4.*(G0[k][5]-G1[k][5])+s1[k]*adjD[0][4]-t4[k]*adjD[1][4];
		G[k][6]=4.*(G0[k][2]-G1[k][6])+s1[k]*adjD[0][2]-t4[k]*adjD[1][2];
		G[k][7]=4.*(G0[k][5]-G1[k][7])+s1[k]*adjD[0][4]-t4[k]*adjD[1][4];
		G[k][8]=4.*(G0[k][8]-G1[k][8])+s1[k]*adjD[0][5]-t4[k]*adjD[1][5];
	}
}



#undef DEBUG_ERR